
#
#  Copyright 2014 CIRAD
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, see <http://www.gnu.org/licenses/> or
#  write to the Free Software Foundation, Inc.,
#  51 Franklin Street, Fifth Floor, Boston,
#  MA 02110-1301, USA.
#
#

import optparse, os, shutil, subprocess, sys, tempfile, fileinput, ConfigParser, operator, time, multiprocessing

def stop_err( msg ):
    sys.stderr.write( "%s\n" % msg )
    sys.exit()

def run_job (cmd_line, ERROR):
	print cmd_line
	try:
		tmp = (tempfile.NamedTemporaryFile().name)+'.error'
		# print tmp
		error = open(tmp, 'w')
		proc = subprocess.Popen( args=cmd_line, shell=True, stderr=error)
		returncode = proc.wait()
		error.close()
		error = open( tmp, 'rb' )
		stderr = ''
		buffsize = 1048576
		try:
			while True:
				stderr += error.read( buffsize )
				if not stderr or len( stderr ) % buffsize != 0:
					break
		except OverflowError:
			pass
		error.close()
		os.remove(tmp)
		if returncode != 0:
			raise Exception, stderr
	except Exception, e:
		stop_err( ERROR + str( e ) )

def create_junction(LIST, OUT):
	file = open(LIST)
	OUTFILE = open(OUT, 'w')
	liste_nom = []
	for line in file:
		data = line.split()
		if data:
			scaff = data[0]
			del data[0]
			while len(data) > 0 :
				OUTFILE.write('\t'.join([scaff,str(int(data[1])-1), str(int(data[1])-1), data[0]])+'\n')
				OUTFILE.write('\t'.join([scaff,str(int(data[2])-1), str(int(data[2])-1), data[0]])+'\n')
				del data[0]
				del data[0]
				del data[0]
	OUTFILE.close()

def __main__():
	#Parse Command Line
	parser = optparse.OptionParser(usage="python %prog [options]\n\nProgram designed by Guillaume MARTIN : guillaume.martin@cirad.fr\n\n"
	"This script verifyies fusions and contigs performed using fusion_scaff.py or contig_scaff.py ")
	# Wrapper options. 
	parser.add_option( '', '--config', dest='config', default='not_filled', help='The conf file generated by conf4circos.py')
	parser.add_option( '', '--list', dest='list', help='The out_verif file generated by fusion_scaff.py')
	parser.add_option( '', '--bound', dest='bound', default=10000, help='Boudary around junction to draw, [default: %default]')
	parser.add_option( '', '--thread', dest='thread', default='1', help='Thread number used for circos drawing (integer), [default: %default]')
	parser.add_option( '', '--out_tar', dest='out_tar', default='verif.tar', help='The archive output file containing all circos generated')
	(options, args) = parser.parse_args()
	
	
	pathname = os.path.dirname(sys.argv[0])
	
	loca_programs = ConfigParser.RawConfigParser()
	loca_programs.read(pathname+'/loca_programs.conf')
	
	proc = int(options.thread)
	
	if options.config == 'not_filled':
		sys.exit('--config argument is missing')
	if options.list == 'not_filled':
		sys.exit('--list argument is missing')
	
	config = ConfigParser.RawConfigParser()
	config.read(options.config)
	
	dic_chr = {}
	file = open(config.get('General','chr'))
	for line in file:
		data = line.split()
		if data:
			dic_chr[data[0]] = int(data[1])
	file.close()
	
	
	tmp_name = tempfile.NamedTemporaryFile().name
	tmp_conf = tmp_name+'.conf'
	tmp_txt = tmp_name+'.txt'
	
	config.set('General','out_N', tmp_txt)
	
	with open(tmp_conf, 'wb') as configfile:
			config.write(configfile)
	
	print tmp_conf
	print tmp_txt
	
	#recording scaffold junction
	create_junction(options.list,tmp_txt)
	
	#drawing circos for each junction
	file = open(options.list)
	liste_nom = []
	liste_process = []
	for line in file:
		data = line.split()
		if data:
			scaff = data[0]
			del data[0]
			del data[0]
			del data[0]
			while len(data) > 1 :
				if ((int(data[0]) - int(options.bound)) <= 0) and ((int(data[2]) + int(options.bound)) >= dic_chr[scaff]):
					mot = scaff+':0:'+str(dic_chr[scaff])
				elif ((int(data[0]) - int(options.bound)) <= 0):
					mot = scaff+':0:'+str(int(data[2]) + int(options.bound))
				elif((int(data[2]) + int(options.bound)) >= dic_chr[scaff]):
					mot = scaff+':'+str(int(data[0]) - int(options.bound))+':'+str(dic_chr[scaff])
				else:
					mot = scaff+':'+str(int(data[0]) - int(options.bound))+':'+str(int(data[2]) + int(options.bound))
				nom = scaff+'-'+data[0]+'-'+data[2]+'.png'
				liste_nom.append(nom)
				del data[0]
				del data[0]
				del data[0]
				redraw = '%s %s/draw_circos.py --config %s --frf n --ff n --rr n --ins n --delet n --chr_rr n --chr_rf n --chr_fr n --chr_ff n --draw %s --out %s --labels n' % (loca_programs.get('Programs','python'), pathname, tmp_conf, mot, nom)
				# run_job(redraw, 'Bug when drawing circos')
				t = multiprocessing.Process(target=run_job, args=(redraw, 'Bug when drawing circos',))
				liste_process.append(t)
				if len(liste_process) == proc:
					# Starts threads
					for process in liste_process:
						process.start()
					# This blocks the calling thread until the thread whose join() method is called is terminated.
					for process in liste_process:
						process.join()
					#the processes are done
					liste_process = []
	if liste_process:
		# Starts threads
		for process in liste_process:
			process.start()
		# This blocks the calling thread until the thread whose join() method is called is terminated.
		for process in liste_process:
			process.join()
		#the processes are done
		liste_process = []
	
	mot = liste_nom[0]
	for n in liste_nom[1:]:
		mot = mot +' '+ n
	archivage = 'tar -cf '+options.out_tar+' '+mot
	run_job(archivage, 'Bug in archive creation')
	for n in liste_nom:
		os.remove(n)

if __name__ == "__main__": __main__()